#!/usr/bin/env bash
#
# tmux-sessionizer
#
# Fuzzy-find a project directory (or git worktree) and create/switch to a tmux
# session rooted there. Handles:
#   - Regular git repos
#   - Bare repos with worktrees (lists each worktree as a separate entry)
#   - Plain directories
#
# Usage:
#   tmux-sessionizer            # interactive fzf picker
#   tmux-sessionizer <path>     # skip picker, go straight to path
#
# Config:
#   Set SESSIONIZER_DIRS to a colon-separated list of search roots.
#   Set SESSIONIZER_DEPTH to control find depth (default: 2).
#
#   Example in fish:
#     set -Ux SESSIONIZER_DIRS "$HOME/Developer:$HOME/dotfiles:$HOME/projects"
#
#   Example in bash/zsh:
#     export SESSIONIZER_DIRS="$HOME/Developer:$HOME/dotfiles:$HOME/projects"

set -euo pipefail

SEARCH_DIRS="${SESSIONIZER_DIRS:-$HOME/Developer:$HOME}"
SEARCH_DEPTH="${SESSIONIZER_DEPTH:-2}"
# Colon-separated list of directory basenames to skip
EXCLUDE_DIRS="${SESSIONIZER_EXCLUDE:-.fzf:.nvm:.oh-my-zsh:.tmux:.cargo}"

# --------------------------------------------------------------------------
# Gather candidate directories
# --------------------------------------------------------------------------
gather_candidates() {
    local IFS=':'
    local seen=()

    for search_dir in $SEARCH_DIRS; do
        [[ ! -d "$search_dir" ]] && continue

        # Find directories containing .git (file or dir) up to SEARCH_DEPTH
        while IFS= read -r gitpath; do
            local project_dir
            project_dir="$(dirname "$gitpath")"

            # Check if this is a bare repo (bare repos have .git/worktrees or
            # the config says bare = true)
            if [[ -d "$gitpath" ]] && git -C "$project_dir" rev-parse --is-bare-repository 2>/dev/null | grep -q true; then
                # Bare repo: list all worktrees
                while IFS= read -r wt_line; do
                    local wt_path
                    wt_path="$(echo "$wt_line" | head -1)"
                    [[ -d "$wt_path" ]] && echo "$wt_path"
                done < <(git -C "$project_dir" worktree list --porcelain | grep "^worktree " | sed 's/^worktree //')
            elif [[ -f "$gitpath" ]]; then
                # .git is a file -> this IS a worktree checkout, include it
                echo "$project_dir"
            else
                # Regular repo. Also check if it has worktrees and list them.
                echo "$project_dir"

                local wt_count
                wt_count=$(git -C "$project_dir" worktree list 2>/dev/null | wc -l)
                if [[ "$wt_count" -gt 1 ]]; then
                    while IFS= read -r wt_line; do
                        local wt_path
                        wt_path="$(echo "$wt_line" | awk '{print $1}')"
                        # Don't duplicate the main worktree
                        [[ "$wt_path" != "$project_dir" && -d "$wt_path" ]] && echo "$wt_path"
                    done < <(git -C "$project_dir" worktree list 2>/dev/null)
                fi
            fi
        done < <(find "$search_dir" -maxdepth "$SEARCH_DEPTH" -name ".git" 2>/dev/null)

        # Also include the search_dir itself if it's a git repo
        if [[ -e "$search_dir/.git" ]]; then
            echo "$search_dir"
        fi
    done | sort -u | while IFS= read -r candidate; do
        local base
        base="$(basename "$candidate")"
        # Check against exclude list
        local excluded=false
        local IFS=':'
        for ex in $EXCLUDE_DIRS; do
            [[ "$base" == "$ex" ]] && excluded=true && break
        done
        [[ "$excluded" == false ]] && echo "$candidate"
    done
}

# --------------------------------------------------------------------------
# Derive a tmux-safe session name from a path
# --------------------------------------------------------------------------
session_name_from_path() {
    local dir="$1"
    local name

    # If inside a git repo, use repo-name (and worktree branch if applicable)
    if git -C "$dir" rev-parse --git-dir &>/dev/null; then
        local toplevel repo_name
        toplevel="$(git -C "$dir" rev-parse --show-toplevel 2>/dev/null || echo "$dir")"
        repo_name="$(basename "$toplevel")"

        # If this is a worktree (not the main checkout), append the branch
        local git_dir
        git_dir="$(git -C "$dir" rev-parse --git-dir 2>/dev/null)"
        if [[ "$git_dir" == *"/worktrees/"* ]]; then
            local branch
            branch="$(git -C "$dir" branch --show-current 2>/dev/null || basename "$dir")"
            name="${repo_name}/${branch}"
        else
            name="$repo_name"
        fi
    else
        name="$(basename "$dir")"
    fi

    # tmux doesn't allow dots or colons in session names
    echo "$name" | tr '.:\n' '_-_'
}

# --------------------------------------------------------------------------
# Create or switch to session
# --------------------------------------------------------------------------
switch_to_session() {
    local dir="$1"
    local name
    name="$(session_name_from_path "$dir")"

    # Create session if it doesn't exist
    if ! tmux has-session -t="$name" 2>/dev/null; then
        tmux new-session -ds "$name" -c "$dir"
    fi

    # Switch or attach
    if [[ -n "${TMUX:-}" ]]; then
        tmux switch-client -t "$name"
    else
        tmux attach-session -t "$name"
    fi
}

# --------------------------------------------------------------------------
# Main
# --------------------------------------------------------------------------
main() {
    local selected

    if [[ $# -ge 1 ]]; then
        selected="$1"
    else
        selected=$(gather_candidates | fzf \
            --prompt="session> " \
            --header="tmux-sessionizer" \
            --preview='
                dir={}
                echo -e "\033[1;34m$(basename {})\033[0m"
                echo ""
                if git -C "$dir" rev-parse --git-dir &>/dev/null; then
                    branch=$(git -C "$dir" branch --show-current 2>/dev/null)
                    echo -e "\033[33mbranch:\033[0m $branch"
                    echo ""
                    echo -e "\033[33mstatus:\033[0m"
                    git -C "$dir" status --short 2>/dev/null
                    echo ""
                    echo -e "\033[33mrecent commits:\033[0m"
                    git -C "$dir" log --oneline -5 2>/dev/null
                else
                    echo "(not a git repo)"
                    ls -la "$dir" 2>/dev/null
                fi
            ' \
            --preview-window=right:50%:wrap \
            --bind='ctrl-d:preview-down,ctrl-u:preview-up' \
        ) || true
    fi

    [[ -z "$selected" ]] && exit 0

    # Resolve to absolute path
    selected="$(cd "$selected" && pwd)"

    switch_to_session "$selected"
}

main "$@"
